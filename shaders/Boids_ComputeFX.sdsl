//Boids Simulation
//original from : Indie Visual Lab
//https://github.com/IndieVisualLab/UnityGraphicsProgrammingSeries
shader Boids_ComputeFX : ComputeShaderBase, ParticleBufferRW, Global //Time and Timestep
{

    float3 WallCenter;
    float3 WallSize;
    float WallForceStrength = .5;

    float SeparationRadius = .5;
    float AlignRadius = .5;
    float CohesionRadius = .25;

    float SeparationStrength = 1.5;
    float AlignStrength = 1.2;
    float CohesionStrength = 2.5;

    float maxVelocity = 1.0;
    float maxForce = .2;


    float3 limit(float3 v, float m)
    {
        float l = sqrt(dot(v, v));
	    return lerp(v * (m / l), v, step(l, m));
    }

    groupshared Particle GroupData[ThreadNumberX];

    override void Compute()
    {
        uint dtid = streams.DispatchThreadId.x;
        uint gtid = streams.GroupThreadId.x;

        //prev frame data
        Particle v = Particles[dtid];

        float3 separation = 0;
        int scnt = 0;
        float3 align = 0;
        int acnt = 0;
        float3 cohesion = 0;
        int ccnt = 0;

        [loop]
        for(uint gi = 0; gi < (uint)(ThreadNumberX * streams.ThreadGroupCount.x);
            gi += ThreadNumberX)
        {
            //setup shared array data per thread group
            Particle d;
            d.Position = Particles[gi + gtid].Position;
            d.Velocity = Particles[gi + gtid].Velocity;
            GroupData[gtid] = d;
            GroupMemoryBarrierWithGroupSync();
            
            for(uint i = 0; i < ThreadNumberX; i++){
                
                float3 fpos = GroupData[i].Position;
                float3 fvel = GroupData[i].Velocity;
                
                float3 dir = v.Position - fpos;
                float dist = sqrt(dot(dir, dir));
                
                //separation
                if(dist > 0.0 && dist <= SeparationRadius){
                    separation += normalize(dir) / dist;
                    scnt++;
                }
                
                //align
                if(dist > 0.0 && dist <= AlignRadius){
                    align += fvel;
                    acnt++;
                }
            
                //cohesion
                if(dist > 0.0 && dist <= CohesionRadius){
                    cohesion += fpos;
                    ccnt++;
                }
            }
            GroupMemoryBarrierWithGroupSync();
        }

        //normalize boids force
        if(scnt >= 1)
        {
            separation /= (float)scnt;
            separation = normalize(separation) * maxVelocity;
            separation -= v.Velocity;
            separation = limit(separation, maxForce);
        }
        if(acnt >= 1)
        {
            align /= (float)acnt;
            align = normalize(align) * maxVelocity;
            align -= v.Velocity;
            align = limit(align, maxForce);
        }
        if(ccnt >= 1)
        {
            cohesion /= (float)ccnt;
            cohesion -= v.Position;
            cohesion = normalize(cohesion) * maxVelocity;
            cohesion -= v.Velocity;
            cohesion = limit(cohesion, maxForce);
        }

        float3 force = 0;
        force += separation * SeparationStrength;
        force += align * AlignStrength;
        force += cohesion * CohesionStrength;

        //wall collision
        float3 wallV = v.Position - WallCenter;
        float3 wallForce = 0;
        wallForce.x = lerp(sign(-wallV.x), 0, step(abs(wallV.x), (WallSize.x / 2)));
        wallForce.y = lerp(sign(-wallV.y), 0, step(abs(wallV.y), (WallSize.y / 2)));
        wallForce.z = lerp(sign(-wallV.z), 0, step(abs(wallV.z), (WallSize.z / 2)));

        force += wallForce * WallForceStrength;

        //update Particle
        float3 velocity = v.Velocity + force * TimeStep;
        float3 position = v.Position + velocity * TimeStep;

        //setup output matrix
        float3 zDir = normalize(velocity);
        float3 xDir = normalize(cross(float3(0,1,0), zDir));
        float3 yDir = normalize(cross(xDir, zDir));
        xDir = normalize(cross(yDir, zDir));

        v.Position = position;
        v.Velocity = velocity;
        v.AxisX = xDir;
        v.AxisY = yDir;
        v.AxisZ = zDir;

        Particles[dtid] = v;
    }
};